// Generated by CoffeeScript 1.3.3
(function() {
  var Game, containsCard, containsSuit, max, newDeck, randomSuit, root, shift, sum, validateBid, validateCardPlayed, validateLastBid, _;

  _ = require("underscore")._;

  Game = (function() {

    function Game(playerLimit) {
      var t, _i, _j, _ref, _results, _results1;
      this.playerLimit = playerLimit;
      this.tricks = [];
      this.scores = [];
      this.players = [];
      this.table = [];
      this.trumps = "";
      this.moves = [];
      this.expectedTurn = null;
      this.scores = {};
      this.begun = false;
      this.callbacks = [];
      this.cards = {};
      t = Math.floor(52 / this.playerLimit);
      this.rounds = (function() {
        _results1 = [];
        for (var _j = 7; 7 <= t ? _j <= t : _j >= t; 7 <= t ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this).concat((function() {
        _results = [];
        for (var _i = _ref = t - 1; _ref <= 1 ? _i <= 1 : _i >= 1; _ref <= 1 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this));
      this.round = 1;
    }

    Game.prototype.getState = function(playerID) {
      var state;
      return state = {
        playerLimit: this.playerLimit,
        table: this.table,
        trumps: this.trumps,
        expectedTurn: this.expectedTurn,
        round: this.round,
        players: this.players,
        hand: this.cards[playerID],
        scores: this.scores,
        tricks: this.tricks
      };
    };

    Game.prototype.join = function(playerID, cb) {
      this.players.push(playerID);
      this.scores[playerID] = 0;
      if (typeof cb === "function") {
        cb();
      }
      if (this.players.length === this.playerLimit) {
        return this.start();
      }
    };

    Game.prototype.playerExists = function(playerID) {
      return this.players.indexOf(playerID) !== -1;
    };

    Game.prototype.start = function(options) {
      var winner;
      console.log('start');
      this.begun = true;
      this.tricks[this.round - 1] = {};
      this.deal(this.rounds[this.round - 1]);
      if (this.round === 1) {
        this.trumps = randomSuit();
        this.expectedTurn = {
          type: "bid",
          playerID: this.players[0]
        };
        return this.callbacks['start'];
      } else {
        winner = options.winner;
        this.expectedTurn = {
          type: "trumps",
          playerID: winner
        };
        return this.callbacks['start'];
      }
    };

    Game.prototype.callback = function(event, data) {
      var callback;
      callback = this.callbacks[event];
      if (callback) {
        return callback(data);
      } else {
        throw "No callback defined for " + event;
      }
    };

    Game.prototype.on = function(event, cb) {
      return this.callbacks[event] = cb;
    };

    Game.prototype.makeMove = function(move, cb) {
      var card_removed, _base, _name;
      console.log('makeMove');
      if (!(move.type === this.expectedTurn.type && move.playerID === this.expectedTurn.playerID)) {
        return;
      }
      if (!(this.validateMove(move))) {
        console.log("invalid move");
        return;
      }
      if (move.type === "trumps") {
        console.log('trumps move');
        this.trumps = move.value;
        this.expectedTurn = {
          type: "bid",
          playerID: this.players[0]
        };
        this.callbacks['update'];
        cb();
        return;
      }
      (_base = this.moves)[_name = this.round - 1] || (_base[_name] = []);
      this.moves[this.round - 1].push(move);
      if (move.type === 'bid') {
        if (move.playerID === this.players[this.players.length - 1]) {
          this.expectedTurn = {
            type: "card",
            playerID: this.players[0]
          };
        } else {
          this.expectedTurn = {
            type: "bid",
            playerID: this.players[this.players.indexOf(move.playerID) + 1]
          };
        }
      } else {
        card_removed = this.cards[move.playerID].remove(move.value);
        this.table.push(move.value);
        if (move.playerID === this.players[this.players.length - 1]) {
          this.concludeTrick();
        } else {
          console.log('trick not ended');
          this.expectedTurn = {
            type: "card",
            playerID: this.players[this.players.indexOf(move.playerID) + 1]
          };
        }
      }
      return cb();
    };

    Game.prototype.concludeTrick = function() {
      var cards, cards_played, suit_led, tricks_played, trumps_played, winner, _base, _name,
        _this = this;
      console.log('concludeTrick');
      cards = this.table;
      winner = null;
      suit_led = cards[0].suit;
      trumps_played = cards.filter(function(card) {
        return card.suit === _this.trumps;
      });
      if (trumps_played.length > 0) {
        winner = max(trumps_played);
      } else {
        cards_played = cards.filter(function(card) {
          return card.suit === suit_led;
        });
        winner = max(cards_played);
      }
      console.log("winner of trick: ", winner.owner);
      (_base = this.tricks[this.round - 1])[_name = winner.owner] || (_base[_name] = 0);
      this.tricks[this.round - 1][winner.owner] += 1;
      tricks_played = (this.moves[this.round - 1].length / this.playerLimit) - 1;
      if (tricks_played === this.rounds[this.round - 1]) {
        console.log('End of round');
        this.calculateScore();
        this.table = [];
        if (this.round === this.rounds.length) {
          console.log("Game over");
          this.expectedTurn = null;
          return this.callbacks['end']();
        } else {
          this.round++;
          return this.start({
            winner: winner.owner
          });
        }
      } else {
        this.table = [];
        this.players = shift(this.players, this.players.indexOf(winner.owner));
        console.log('new players order', this.players);
        this.expectedTurn = {
          type: "card",
          playerID: this.players[0]
        };
        return console.log("here");
      }
    };

    Game.prototype.calculateScore = function() {
      var bid, bids, playerID, prevScore, score, tricks, _base, _i, _len, _name, _ref, _ref1, _ref2, _results;
      bids = this.moves[this.round - 1].slice(0, this.playerLimit);
      _ref = this.tricks[this.round - 1];
      for (playerID in _ref) {
        tricks = _ref[playerID];
        bid = bids.filter(function(move) {
          return move.playerID === playerID;
        });
        bid = bid[0].value;
        console.log('tricks: ', tricks);
        console.log('bid: ', bid);
        score = 0;
        if (tricks < bid) {
          score = tricks;
        }
        if (tricks === bid) {
          score = tricks + 10;
        }
        if (tricks > bid) {
          score = bid - tricks;
        }
        console.log('score: ', score);
        prevScore = this.scores[playerID];
        if ((_ref1 = (_base = this.scores)[_name = this.round - 1]) == null) {
          _base[_name] = {};
        }
        this.scores[this.round - 1][playerID] = prevScore + score;
        this.scores[playerID] = this.scores[this.round - 1][playerID];
      }
      _ref2 = this.players;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        playerID = _ref2[_i];
        _results.push(console.log('player ', playerID, ' score: ', this.scores[playerID]));
      }
      return _results;
    };

    Game.prototype.validateMove = function(move) {
      var prevBids;
      if (move.type === "bid") {
        prevBids = this.moves[this.round - 1];
        if (move.playerID === this.players[this.players.length - 1]) {
          return validateLastBid(move.value, this.rounds[this.round - 1], prevBids);
        } else {
          return validateBid(move.value, this.rounds[this.round - 1]);
        }
      } else if (move.type === "card") {
        return validateCardPlayed(move.value, this.cards[move.playerID], this.trumps, this.table[0] || move.value);
      } else if (move.type === "trumps") {
        if (_.include(["C", "D", "H", "S"], move.value)) {
          return true;
        }
      }
    };

    Game.prototype.deal = function(number) {
      var card, deck, i, p, _i, _j, _k, _len, _len1, _ref, _ref1;
      deck = newDeck();
      _ref = this.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        this.cards[p] = [];
      }
      for (i = _j = 1; 1 <= number ? _j <= number : _j >= number; i = 1 <= number ? ++_j : --_j) {
        _ref1 = this.players;
        for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
          p = _ref1[_k];
          card = deck[0];
          card.owner = p;
          this.cards[p].push(card);
          deck.splice(0, 1);
        }
      }
      return console.log('cards dealt', this.cards);
    };

    return Game;

  })();

  shift = function(array, index) {
    return _.rest(array, index).concat(_.first(array, index));
  };

  Array.prototype.remove = function(obj) {
    var removed_obj,
      _this = this;
    removed_obj = null;
    _.each(this, function(o) {
      if (_.isEqual(o, obj)) {
        _this.splice(_this.indexOf(o), 1);
        return removed_obj = o;
      }
    });
    return removed_obj;
  };

  max = function(cards) {
    var c, card, val, _i, _len;
    card = {
      number: 0
    };
    for (_i = 0, _len = cards.length; _i < _len; _i++) {
      c = cards[_i];
      val = (function() {
        switch (c.number) {
          case "A":
            return 14;
          case "K":
            return 13;
          case "Q":
            return 12;
          case "J":
            return 11;
          default:
            return c.number - 0;
        }
      })();
      if (val > card.number) {
        card = c;
      }
    }
    return card;
  };

  randomSuit = function() {
    return ["C", "D", "H", "S"][Math.floor(Math.random() * 4)];
  };

  newDeck = function() {
    var card, deck, i, n, numbers, s, suits, _i, _j, _k, _len, _len1, _len2, _ref;
    deck = [];
    numbers = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
    suits = ["C", "D", "H", "S"];
    for (_i = 0, _len = suits.length; _i < _len; _i++) {
      s = suits[_i];
      for (_j = 0, _len1 = numbers.length; _j < _len1; _j++) {
        n = numbers[_j];
        card = {
          suit: s,
          number: n,
          owner: null
        };
        deck.push(card);
      }
    }
    for (i = _k = 0, _len2 = deck.length; _k < _len2; i = ++_k) {
      card = deck[i];
      n = Math.floor(Math.random() * deck.length);
      _ref = [deck[n], deck[i]], deck[i] = _ref[0], deck[n] = _ref[1];
    }
    return deck;
  };

  validateBid = function(bid, number_of_tricks) {
    return bid > 0 && bid < number_of_tricks;
  };

  validateCardPlayed = function(card, hand, trumps, card_led) {
    if (!containsCard(hand, card)) {
      console.log("card is not in player's hand", card, hand);
      return false;
    }
    if (card.suit === trumps) {
      if (containsSuit(hand, card_led.suit) && card_led.suit !== trumps) {
        console.log("player is able to follow suit but has not");
        return false;
      } else {
        return true;
      }
    }
    if (card.suit === card_led.suit) {
      return true;
    }
    if (containsSuit(hand, card_led.suit)) {
      console.log("player is able to follow suit but has not");
      return false;
    } else {
      return true;
    }
  };

  validateLastBid = function(bid, number_of_tricks, previousBids) {
    return validateBid(bid, number_of_tricks) && bid !== number_of_tricks - sum(previousBids);
  };

  containsSuit = function(cards, suit) {
    var c, _i, _len;
    for (_i = 0, _len = cards.length; _i < _len; _i++) {
      c = cards[_i];
      if (c.suit === suit) {
        return true;
      }
    }
    return false;
  };

  containsCard = function(cards, card) {
    var c, _i, _len;
    for (_i = 0, _len = cards.length; _i < _len; _i++) {
      c = cards[_i];
      if (c.suit === card.suit && c.number === card.number) {
        return true;
      }
    }
    return false;
  };

  sum = function(array) {
    var n, t, _i, _len;
    t = 0;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      n = array[_i];
      t += n;
    }
    return t;
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.Game = Game;

}).call(this);
